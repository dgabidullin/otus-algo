### Измерения 100000 операций, мс

|                  | add(0) | add(elem, arr.size()) | add(elem, arr.size() / 2) | remove(0) | remove(data.size() - 1) |
|------------------|--------|-----------------------|---------------------------|-----------|-------------------------|
| SingleArray      | 4275   | 3257                  | 3489                      | 3127      | 2132                    |
| VectorArray      | 782    | 303                   | 504                       | 589       | 7                       |
| FactorArray      | 551    | 5                     | 258                       | 542       | 5                       |
| MatrixArray      | 33515  | 6                     | 13793                     | 26358     | 10                      |
| ArrayListWrapper | 590    | 2                     | 259                       | 527       | 2                       |

### Вывод
В таблицу измерений не добавлены операции чтения, тк. показалось не очень интересным, потому что у структур данных, концептуально, которые измеряли, внутри хранилка в виде массива(или массива массивов), где произвольный доступ по индексу O(1)

1. ***SingleArray*** массив с начальным размером 1. На больших массивах будет не оптимальным на операциях добавить/удалить элемент тк. каждый раз будет выполнена переаллокация памяти на массив нового размера + выполнена операция копирования.
2. ***VectorArray*** более оптимальный вариант по сравнению с SingleArray, тк. переаллокация памяти на новый происходит не всегда, а только при достижении порогового значения для размера массива, в результате вставка/удаление только копируют часть элементов в массиве. Оптимальными операциями являются добавление/удаления элемента в конец, тк. дополнительного копирования не происходит.
3. ***FactorArray*** оптимизированный вариант VectorArray, при переполнении будет выделена память пропорционально размеру массива (более оптимален для "больших" массивов, но, в то же время, часть выделенной может быть не использована - перерасход). Оптимальными операциями являются добавление/удаления элемента в конец, тк. дополнительного копирования не происходит.
4. ***MatrixArray*** в зависимости от реализации переиспользует одну из хранилок SingleArray/VectorArray, концептуально, будет массив массивов. При добавлении/удалении в начало концептуально похож на SingleArray, но теперь копирование элементов вместо одной большой пачкой - пачками маленьких, на каждый слот.
5. ***ArrayListWrapper*** переиспользует стандартную java коллекцию ArrayList, в основе идея с FactorArray и пропорциональным выделением памяти. Операции добавление/удаление в конец наиболее оптимальны.
