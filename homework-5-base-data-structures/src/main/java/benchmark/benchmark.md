### Измерения 100000 операций, мс

|                  | add(0) | add(elem, arr.size()) | add(elem, arr.size() / 2) | remove(0) | remove(data.size() - 1) |
|------------------|--------|-----------------------|---------------------------|-----------|-------------------------|
| SingleArray      | 4275   | 3257                  | 3489                      | 3127      | 2132                    |
| VectorArray      | 782    | 303                   | 504                       | 589       | 7                       |
| FactorArray      | 551    | 5                     | 258                       | 542       | 5                       |
| MatrixArray      | 33515  | 6                     | 13793                     | 26358     | 10                      |
| ArrayListWrapper | 590    | 2                     | 259                       | 527       | 2                       |

### Вывод
В таблицу измерений не добавлены операции чтения, показалось, не очень интересным - тк. у структур данных, концептуально, которые измеряли, внутри хранилка в виде массива(или массива массивов), где произвольный доступ по индексу O(1)

1. ***SingleArray*** Массив с начальным размером 1. На больших массивах будет не оптимальный вариант на операциях добавить/удалить элемент тк. каждый раз будет выполнена переаллокация памяти на массив нового размера.
2. ***VectorArray*** и ***FactorArray*** более оптимальный вариант по сравнению с SingleArray, заранее создается хранилка с более большим объемом свободных ячеек в массиве, где для VectorArray выделяется фиксированный размер и при переполнении увеличивается на этот фикс, а FactorArray пропорционально размеру массива (более оптимален для "больших" массивов, но в то же время, часть выделенной может быть не использована - перерасход). Операции добавление/удаление в конец наиболее оптимальны.
3. ***MatrixArray*** в зависимости от реализации переиспользует одну из хранилок SingleArray/VectorArray, концептуально, будет массив массивов. Не оптимально работает идея с массивами внутри слотов (массивов) на операциях добавления в начало/середину - имеет наихудший показатель по времени.
4. ***ArrayListWrapper*** переиспользует стандартную java коллекцию ArrayList, в основе идея с FactorArray и пропорциональным выделением памяти.
