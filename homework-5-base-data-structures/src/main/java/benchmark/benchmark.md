|                  | add(0) | add(elem, arr.size()) | add(elem, arr.size() / 2) | remove(0) | remove(data.size() - 1) |
|------------------|--------|-----------------------|---------------------------|-----------|-------------------------|
| SingleArray      | 4275   | 3257                  | 3489                      | 3127      | 2132                    |
| VectorArray      | 782    | 303                   | 504                       | 589       | 7                       |
| FactorArray      | 551    | 5                     | 258                       | 542       | 5                       |
| MatrixArray      | 33515  | 6                     | 13793                     | 26358     | 10                      |
| ArrayListWrapper | 590    | 2                     | 259                       | 527       | 2                       |

### Вывод
1. SingleArray неоптимальный вариант, при операции добавить/удалить каждый раз заново выделяется память на внутреннюю хранилку.
2. VectorArray и FactorArray более оптимальный вариант по сравнению с SingleArray, заранее создается хранилка с более большим объемом свободных ячеек в массиве, где для VectorArray выделяется фиксированный размер и при переполнении увеличивается на этот фикс, а FactorArray пропорционально размеру массива (более оптимален для "больших" массивов, но в то же время, часть выделенной может быть не использована - перерасход). Операции добавление/удаление в конец наиболее оптимальны.
3. MatrixArray в зависимости от реализации переиспользует одну из хранилок SingleArray/VectorArray, внутри будет массив массивов. При добавлении в начало/середину имеет наихудший показатель по времени.
4. ArrayListWrapper переиспользует стандартную java коллекцию ArrayList, в основе идея с FactorArray и пропорциональным выделением памяти при переполнении.
У приведенных выше стуктур данных слуйный доступ по индексу O(1)